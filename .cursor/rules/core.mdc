---
description: Core workflow rules - project scope, commits, responses, progress checks
alwaysApply: true
---

# Active Project Scope (CRITICAL)

Before giving any instructions, code, or analysis, confirm the active project:
- App name
- Local folder path
- GitHub repository name
- Supabase project name (if applicable)

Rules:
- Never assume the active project
- Never mix context between projects
- If the active project is not confirmed, STOP and ask

# Repository Access

You have direct read access to the codebase via MCP.

Rules:
- Read files yourself before suggesting changes
- Never assume files that do not exist
- If something is unclear, inspect the repo before asking

NEVER ask the user to:
- Paste code or file contents
- Share what's in a file
- Describe file contents

The only exceptions (you may ask for):
- Browser console output
- Terminal output from local commands
- Error messages from Cursor UI
- Screenshots of visual bugs

# Commit Checkpoints

Git commits are save points. Prompt to commit:
- After completing a working feature
- Before risky or experimental changes
- After fixing a blocking bug
- Every 3-5 tasks when something meaningful works

Commit guidance:
- Short, clear messages (e.g. "Add login button", "Fix auth redirect bug")
- Don't commit broken code unless saving WIP
- Prefer Cursor Agent for git operations

# How to Respond

## 0. New vs Existing App Gate
Confirm: new or existing? App name? Folder path? GitHub repo? Active project?

## 1. Start With a Plan
When starting an app: explain what we're building, confirm structure, list phases, stop and ask if ready.

## 2. Information vs Interpretation: When to Act vs Confirm

**For INFORMATION (Never Ask - Use Tools):**
- File contents → Read it yourself
- Console errors → Check Playwright
- What's in the database → Query it yourself
- Network requests → Inspect them yourself

→ **Use tools automatically. Never ask for information you can retrieve.**

**For INTERPRETATION (Always Confirm First):**
- Which element to modify
- What behavior you want
- Which approach to take (if multiple options)
- Risky changes (deletion, refactors)

→ **Restate understanding. Wait for confirmation.**

**When You May Skip Confirmation:**
- ✅ Task is unambiguous ("fix the console error on line 47")
- ✅ Evidence is clear from repo/logs (bug has obvious cause)
- ✅ Following exact instructions with no interpretation needed
- ✅ Fixing something you just broke

**When Confirmation is REQUIRED:**
- ❌ Multiple ways to interpret the request
- ❌ Deleting or refactoring code
- ❌ Unclear which file/component to modify
- ❌ Trade-offs between approaches

## Bug Fix Workflow: REFLECT → CODE → TEST → DELIVER

When fixing bugs, ALWAYS follow this workflow:

### 1. BEFORE Implementing (REFLECT)
- Think deeply about the solution
- Confirm the logic would work
- Verify all edge cases
- Be reflective - don't rush to code
- Ask yourself: "Is this the right fix? What could go wrong?"

### 2. AFTER Implementing (TEST)
- For complex tasks: test it yourself FIRST
- Use the fastest testing method possible:
  - Browser testing (if available)
  - Code trace (walk through logic)
  - Console logs analysis
- Only ask user to test after you've verified it works

### 3. If Testing Seems Complex
- STOP and ask user: "Should I test this?"
- Don't waste time on overly complex testing
- Get user approval before proceeding

Why:
✓ Saves user's time - no testing half-baked code
✓ Higher quality - verified before delivery
✓ More efficient - fast testing, less back-and-forth
✓ Thoughtful - reflection prevents rushed mistakes

## Confirmation Workflow (When Confirmation is Required)

When the task requires interpretation:

### Workflow (MANDATORY):
1. **User asks** question or gives task
2. **I interpret** - explain my understanding clearly
3. **I ask** - "Did I understand correctly?" or similar
4. **User confirms** - wait for "yes", "correct", "y", etc.
5. **ONLY THEN** - start implementing

### Never Skip This Step (When Confirmation is Required):
- ❌ Don't implement immediately when ambiguous
- ❌ Don't assume you understood
- ❌ Don't start coding without confirmation
- ✅ Always restate the task in your own words
- ✅ Always wait for explicit confirmation
- ✅ Then proceed with implementation

### Why This Matters:
- Prevents misunderstandings (wrong element, wrong file, wrong logic)
- Saves time (no back-and-forth fixes)
- Builds trust (user knows we're aligned)
- Higher quality (we're solving the right problem)

### Example:
```
User: "Fix the alignment issue"

Agent: "Let me confirm I understand:
- You want the header title aligned with sidebar sections
- Not the sidebar card itself
- Header padding should match sidebar (20px)
Did I understand correctly?"

User: "yes"

Agent: [NOW implements the fix]
```

## 3. Step-by-Step Execution
For each task, tell me:
- Which tool (Cursor, Cursor Agent, Supabase, etc.)
- Exactly what to click, type, or create
- Exactly which file or folder
- What success looks like

Then stop and wait.

## 4. Code Handling
- Provide copy-paste-ready code
- Label clearly: "Create this file" or "Replace everything in this file"
- Explain what the code does in plain language

# Progress Check-Ins

Every 10 responses, or when asked, enter check-in mode:
- What we've completed (3-5 bullets)
- What remains (3-5 bullets)
- Progress estimate: 0% to 100%

No new tasks during check-ins.

# Escalation Protocol

If 3+ fixes fail for the same issue:

1. Pause and summarize: what we tried, what failed, what the error is
2. Ask for additional context: official docs, version numbers, migration guides
3. Suggest alternatives: different approach, different model, simplify, revert
4. Let the user decide before switching

Official docs to reference:
- Next.js: nextjs.org/docs
- React: react.dev
- Supabase: supabase.com/docs
- Tailwind: tailwindcss.com/docs
- Vercel: vercel.com/docs
